---
title: ì•Œê³ ë¦¬ì¦˜ ìŠ¤í„°ë”” 2ì£¼ì°¨
key: ì•Œê³ ë¦¬ì¦˜ ìŠ¤í„°ë”” 2ì£¼ì°¨
tags: Algorithm, C++
layout: article
---

[LeetCode Top Interview Questions [Medium Collection]](https://leetcode.com/explore/interview/card/top-interview-questions-medium/)

Array and Strings

# **Longest Substring Without Repeating Characters**

[Explore - LeetCode](https://leetcode.com/explore/interview/card/top-interview-questions-medium/103/array-and-strings/779/)

<aside>
ğŸ’¡

Given a stringÂ `s`, find the length of theÂ **longest**Â **substring**Â without duplicate characters.

â‡’ ê°ê°ì˜ ë¬¸ìì—´ì´ í•œë²ˆë§Œ ë‚˜ì˜¤ëŠ” ìµœì¥ ê¸¸ì´ì˜ stringì„ ì°¾ê¸°

</aside>

## ì ‘ê·¼ ë°©ì‹

1. Setì´ë‚˜ mapë“±ì— ë„£ì–´ì„œ ì¤‘ë³µì„ ì°¾ëŠ”ë‹¤.
   1. Indexë¥¼ ìºì‹± í•´ë‘ì—ˆë‹¤ê°€, ì¤‘ë³µì´ ê²€ì¶œë˜ë©´ í•´ë‹¹ Indexë¶€í„° ì‹œì‘
   2. TowPointerì„ ì‚¬ìš©í•´ì„œ ì¤„ì´ëŠ” ë°©ì‹ ì‚¬ìš©

## Indexë¥¼ ìºì‹± í•´ë‘ì—ˆë‹¤ê°€, ì¤‘ë³µì´ ê²€ì¶œë˜ë©´ í•´ë‹¹ Indexë¶€í„° ì‹œì‘

**606ms(5.13%)â€¦**

- `O(n^2)`

  ```cpp
  class Solution
  {
  public:
      int lengthOfLongestSubstring(string s)
      {
          unordered_set<char> array;
          int answer = 0, lenth = 0;
          int cachedIndex = 0;

          for (int i = 0; i < s.length();)
          {
              auto iter = array.find(s[i]);
              if (iter == array.end())
              {
                  lenth++;
                  if (lenth == 2)
                  {
                      cachedIndex = i;
                  }
              }
              else
              {
                  answer = max(answer, lenth);
                  lenth = 1;
                  array.clear();
                  i = cachedIndex++;
              }
              array.insert(s[i]);
              i++;
          }

          answer = max(answer, lenth);
          return answer;
      }
  };
  ```

## TowPointer

ì¢Œ, ìš° í¬ì¸í„°ë¥¼ ë§Œë“¤ì–´ì„œ í•œìª½ìœ¼ë¡œ ê°€ë‹¤ê°€ ì¤‘ë³µì„ ë§Œë‚˜ë©´ ë°˜ëŒ€ìª½ í¬ì¸í„°ë¥¼ ì¤„ì—¬ ê²€ì‚¬ë¥¼ ìµœì†Œí™” í•˜ê²Œ ìˆ˜ì •

**19ms 30.52%**

í‰ê·  - `O(n)`

```cpp
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        unordered_set<char> seen;
        int ans = 0, length = 0;
        int L = 0;

        for (int R = 0; R < s.size(); ++R)
        {
            while (seen.count(s[R]))
            {
                seen.erase(s[L++]);
                length--;
            }
            seen.insert(s[R]);
            ans = max(ans, length + 1);
            length++;
        }
        return ans;
    }
};
```

# **Longest Palindromic Substring**

[Explore - LeetCode](https://leetcode.com/explore/interview/card/top-interview-questions-medium/103/array-and-strings/780/)

<aside>
ğŸ’¡

Given a stringÂ `s`, returnÂ *the longest*Â *palindromic*Â *substring*Â inÂ `s`.

*palindromic*Â : íšŒë¬¸í˜•, ì¢Œìš°ê°€ ë™ì¼í•œ ë¬¸ìì—´ (ê¸°ëŸ¬ê¸°, í† ë§ˆí† , ìŠ¤ìœ„ìŠ¤â€¦)

â‡’ ìµœì¥ íšŒë¬¸í˜• ë¬¸ìì—´ì„ ì°¾ì•„ë¼

</aside>

## ì ‘ê·¼ ë°©ì‹

íˆ¬í¬ì¸í„°ë¥¼ ì‚¬ìš© í•´ì„œ, íŠ¹ì • ë¬¸ìì—ì„œ ì¢Œìš°ë¡œ ë»—ì–´ê°€ë©´ ë ê²ƒ ê°™ë‹¤.

## íˆ¬í¬ì¸í„°

`O(2n)`

**Runtime : 20ms 53.74%
Memory : 35.3MB 29.24%**

```cpp
class Solution
{
public:
    string longestPalindrome(string s)
    {
        string ans;

        for (int centerIndex = 0; centerIndex < s.size(); ++centerIndex)
        {
            int L = centerIndex, R = centerIndex;
            while (L - 1 >= 0 && s[centerIndex] == s[L - 1])
            {
                L--;
            }

            while (R + 1 <= s.size() && s[centerIndex] == s[R + 1])
            {
                R++;
            }

            while (L - 1 >= 0 && R + 1 <= s.size() && s[L - 1] == s[R + 1])
            {
                L--;
                R++;
            }

            int len = R - L + 1;

            ans = ans.size() > len ? ans : s.substr(L, R - L + 1);
        }
        return ans;
    }
};
```

## ê°œì„ 

- substrì„ ë„ˆë¬´ ë§ì´í•´ì„œ len, indexë§Œ ì–»ì€ ë’¤ì— ë§ˆì§€ë§‰ì— substrí•˜ë©´ ê°œì„ ì´ ë ê²ƒ ê°™ìŒ.

**Runtime : 3ms 97.90%
Memory : 9.3MB 82.01%**

`O(n)`

```cpp
class Solution
{
public:
    string longestPalindrome(string s)
    {
        int bestL = 0, bestLen = 0;

        for (int centerIndex = 0; centerIndex < s.size(); ++centerIndex)
        {
            int L = centerIndex, R = centerIndex;
            while (R + 1 < s.size() && s[R + 1] == s[centerIndex])
                R++;

            while (L - 1 >= 0 && R + 1 < s.size() && s[L - 1] == s[R + 1])
            {
                L--;
                R++;
            }

            if (R - L + 1 > bestLen)
            {
                bestLen = R - L + 1;
                bestL = L;
            }
        }
        return s.substr(bestL, bestLen);
    }
};
```

# Increasing Triplet Subsequence

<aside>
ğŸ’¡

Given an integer arrayÂ `nums`, returnÂ `true`Â *if there exists a triple of indices*Â `(i, j, k)`Â *such that*Â `i < j < k`Â *and*Â `nums[i] < nums[j] < nums[k]`. If no such indices exists, returnÂ `false`.

â‡’ 3ê°œì˜ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆëŠ” ìš”ì†Œê°€ ìˆëŠ”ì§€ë¥¼ ì°¾ëŠ” ë¬¸ì œ

</aside>

[Explore - LeetCode](https://leetcode.com/explore/interview/card/top-interview-questions-medium/103/array-and-strings/781/)

## ì ‘ê·¼ ë°©ì‹

ë°±ì¤€ì˜ ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ ì´ ìƒê°ë‚˜ì„œ ê·¸ì— ë§ê²Œ í’€ì—ˆìŒ.

- arrayì— ë‹´ê³ , ê·¸ê²ƒë³´ë‹¤ í° ìˆ˜ê°€ ë“¤ì–´ì™”ìœ¼ë©´ ë’¤ì— ì¶”ê°€, ë‚®ì€ ìˆ˜ê°€ ë“¤ì–´ì˜¤ë©´ ëŒ€ì¹˜í•œë‹¤.
- lower_bound ì‚¬ìš©
  > ì°¾ìœ¼ë ¤ëŠ” key ê°’ë³´ë‹¤ ê°™ê±°ë‚˜ í° ìˆ«ìê°€ ë°°ì—´ ëª‡ ë²ˆì§¸ì—ì„œ ì²˜ìŒ ë“±ì¥

## LIS(ìµœì¥ ì¦ê°€ ë¶€ë¶„ìˆ˜ì—´)

**Runtime : 6ms 15.77%
Memory : 115.5MB 98.08%**

**`O(n log n)`**

```cpp
class Solution
{
public:
    bool increasingTriplet(vector<int> &num)
    {
        vector<int> tails;
        for (int x : num)
        {
            auto it = lower_bound(tails.begin(), tails.end(), x);
            if (it == tails.end())
            {
                if (tails.size() >= 2)
                    return true;
                tails.push_back(x);
            }
            else
            {
                *it = x;
            }
        }
        return false;
    }
};
```
