---
title: ì•Œê³ ë¦¬ì¦˜ ìŠ¤í„°ë”” 4ì£¼ì°¨
key: ì•Œê³ ë¦¬ì¦˜ ìŠ¤í„°ë”” 4ì£¼ì°¨
tags: Algorithm, C++
layout: article
---

[LeetCode Top Interview Questions [Medium Collection]](https://leetcode.com/explore/interview/card/top-interview-questions-medium/)

Tree And Graph

# Binary Tree Inorder Traversal

[Explore - LeetCode](https://leetcode.com/explore/interview/card/top-interview-questions-medium/108/trees-and-graphs/786/)

- ê·¸ëƒ¥ ì¤‘ìœ„ ìˆœíšŒ í•˜ë©´ë¨. ì¬ê·€ í˜¸ì¶œ
    <aside>
    ğŸ’¡
    
    ì¤‘ìœ„ ìˆœíšŒ â‡’ ì™¼ìª½ - ì¤‘ê°„ - ì˜¤ë¥¸ìª½ ìœ¼ë¡œ íƒìƒ‰í•œë‹¤.
    
    DFSë¡œ ìµœí•˜ìœ„ ë…¸ë“œë¶€í„° íƒ€ê³  ì˜¬ë¼ì˜¤ë©´ ëœë‹¤.
    
    </aside>

```cpp
class Solution
{
    void inOrderTraversal(TreeNode *root, vector<int> &v)
    {
        if (root == nullptr)
            return;

        // ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì¤‘ìœ„ ìˆœíšŒ
        inOrderTraversal(root->left, v);

        // ë£¨íŠ¸ ë…¸ë“œë¥¼ ë°©ë¬¸
        v.push_back(root->val);

        // ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì¤‘ìœ„ ìˆœíšŒ
        inOrderTraversal(root->right, v);
    }

public:
    vector<int> inorderTraversal(TreeNode *root)
    {
        vector<int> a;
        inOrderTraversal(root, a);

        return a;
    }
};
```

# **Binary Tree Zigzag Level Order Traversal**

[Explore - LeetCode](https://leetcode.com/explore/interview/card/top-interview-questions-medium/108/trees-and-graphs/787/)

- BFSë¥¼ í†µí•´ í•´ë‹¹ ê°’ì„ ì €ì¥í•œ ë’¤ì— reverseë¥¼ í†µí•´ ëŒë ¤ì¤Œ.
  ì •ë°©í–¥ ì—­ë°©í–¥ì€, countë¥¼ ì„¸ì„œ í•˜ì˜€ë‹¤.

```cpp
class Solution
{
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode *root)
    {
        vector<vector<int>> ans;
        queue<TreeNode *> q;

        if (root != nullptr)
        {
            q.push(root);
        }

        int count = -1;
        while (!q.empty())
        {
            count++;
            ans.push_back({});
            int num = q.size();
            for (int i = 0; i < num; ++i)
            {
                TreeNode *node;
                // ì •ë°©í–¥ ì—­ë°©í–¥
                node = q.front();
                q.pop();
                if (node == nullptr)
                {
                    continue;
                }

                ans[count].push_back(node->val);

                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }

            if (count % 2 == 1)
            {
                reverse(ans[count].begin(), ans[count].end());
            }
        }

        return ans;
    }
};
```

# **Construct Binary Tree from Preorder and Inorder Traversal**

[Explore - LeetCode](https://leetcode.com/explore/interview/card/top-interview-questions-medium/108/trees-and-graphs/788/)

- ì „ìœ„ ìˆœíšŒì™€ ì¤‘ìœ„ ìˆœíšŒê°€ ì£¼ì–´ì§ˆ ê²½ìš° ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬ì„±
  í’€ì´ ë°©ë²•ì´ ì¡°ê¸ˆ ì–´ë ¤ì› ë‹¤.
  ë¶„í•  ì •ë³µìœ¼ë¡œ í•´ê²°.

  1. `preorder`ì˜ 1ë²ˆì€ rootì— í•´ë‹¹. `inorder`ì„ ê¸°ì¤€ìœ¼ë¡œ rootì˜ ì¢Œìš°ë¡œ ë‚˜ë‰œë‹¤.
  2. ì¢Œ/ìš° ë¦¬ìŠ¤íŠ¸ì—ì„œ rootë¥¼ ì°¾ì€ ë‹¤ìŒì— í•´ë‹¹ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ `inorder`, `preorder`ì„ ë‚˜ëˆ„ê³  ë‹¤ì‹œ ì„œì¹˜í•˜ê²Œ í•¨.

     ex)`preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]`
     ìœ„ì™€ ê°™ì€ ê°’ì´ ë“¤ì–´ì˜¨ë‹¤.

  3. root = 3 (`preorder[0]`)
  4. inorderì—ì„œ 3ì„ ê¸°ì¤€ìœ¼ë¡œ ì¢Œìš°ë¡œ ë‚˜ëˆˆë‹¤.

     1. `ì¢Œ = inorder = [9]`, `preorder =[9]`

        â‡’ root = 9ë¡œ ì¢…ë£Œ

     2. `ìš° = inorder = [15,20,7]`, `preorder = [20,15,7]`

        â‡’ root = `preorder [0] = 20`, `inorder` ì—ì„œ `20`ì„ ê¸°ì¤€ìœ¼ë¡œ ë¶„í• 

  5. ì¢Œ, ìš° ì—ì„œ í•´ë‹¹ì„ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ë‚˜ëˆˆë‹¤.

     ìš°ì¸¡ ë…¸ë“œ`(20 = root)` ê¸°ì¤€ìœ¼ë¡œ

     1. ì¢Œ root = 15
     2. ìš° root = 7

![image.png](/assets/images/Algorithm/Algorithm 4-1.png)

```cpp
class Solution
{
    TreeNode *build(
        const vector<int> &preorder, const int preStart,
        const int inStart, const int inEnd,
        const unordered_map<int, int> &inorderIndex)
    {
        if (inStart > inEnd)
            return nullptr;

        int rootVal = preorder[preStart];
        TreeNode *root = new TreeNode(rootVal);

        const int ValueIndex = inorderIndex.at(rootVal);
        int leftSize = ValueIndex - inStart;

        // ì¢Œ/ìš° ì„œë¸ŒíŠ¸ë¦¬ ì¬ê·€ í˜¸ì¶œ idxê°’ì„ ì¤‘ì‹¬ìœ¼ë¡œ ì¢Œìš°ë¡œ ë‚˜ëˆˆë‹¤.
        // ì¢Œ [inStart, idx - 1]
        // ìš° [idx + 1, inEnd]
        root->left = build(preorder, preStart + 1, inStart, ValueIndex - 1, inorderIndex);
        root->right = build(preorder, preStart + 1 + leftSize, ValueIndex + 1, inEnd, inorderIndex);

        return root;
    }

public:
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder)
    {
        // inorder ê°’ -> ì¸ë±ìŠ¤ ë§µ
        // Find ì½”ìŠ¤íŠ¸ë¥¼ ì•„ë¼ê¸° ìœ„í•´ unordered_mapì‚¬ìš©
        unordered_map<int, int> inorderIndex;
        for (int i = 0; i < inorder.size(); i++)
            inorderIndex[inorder[i]] = i;

        return build(preorder, 0, 0, inorder.size() - 1, inorderIndex);
    }
};
```
